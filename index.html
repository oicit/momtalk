<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>霓虹重力核心 PRO</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; }
        #ui-layer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #0ff;
            z-index: 10;
            pointer-events: none;
            width: 100%;
        }
        h1 {
            font-size: 24px;
            text-shadow: 0 0 10px #0ff;
            margin-bottom: 30px;
            letter-spacing: 4px;
        }
        #start-btn {
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #0ff;
            color: #0ff;
            padding: 15px 40px;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 15px #0ff, inset 0 0 10px rgba(0, 255, 255, 0.2);
            border-radius: 4px;
        }
        #start-btn:active { background: #0ff; color: #000; box-shadow: 0 0 30px #0ff; }
        #debug {
            position: absolute;
            bottom: 15px;
            left: 15px;
            color: rgba(0, 255, 255, 0.7);
            font-size: 10px;
            pointer-events: none;
            text-shadow: 0 0 5px #0ff;
        }
        #instructions {
            margin-top: 15px;
            font-size: 12px;
            opacity: 0.7;
        }
    </style>
    <!-- 使用 Import Map 管理 ES Module 依赖 -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>
    <!-- 修复：通过全局 Script 标签加载 Tone.js 以避免 ESM 导入错误 -->
    <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
</head>
<body>

    <div id="ui-layer">
        <h1>NEON GRAVITY CORE</h1>
        <button id="start-btn">初始化系统</button>
        <div id="instructions">佩戴耳机体验最佳<br>倾斜设备控制核心</div>
    </div>
    <div id="debug">系统待机...</div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import * as CANNON from 'cannon-es';
        
        // 注意：Tone.js 现在作为全局对象 'Tone' 直接使用，无需 import

        // --- 变量定义 ---
        let scene, camera, renderer, composer;
        let world, sphereBody, wallMaterial;
        let coreMesh, innerCoreMesh, particles;
        let synth, noiseSynth, metalSynth;
        let isRunning = false;
        
        // 物理世界参数
        const boundarySize = 6; // 物理墙壁的范围

        // 陀螺仪数据
        let deviceBeta = 0, deviceGamma = 0;

        init();

        function init() {
            // 1. Three.js 场景设置
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.03);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.z = 8;

            renderer = new THREE.WebGLRenderer({ antialias: false }); // Post-processing 开启时通常关闭原生抗锯齿以提升性能
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping;
            document.body.appendChild(renderer.domElement);

            // 2. 后期处理 (Bloom Effect)
            const renderScene = new RenderPass(scene, camera);
            
            // 参数: resolution, strength, radius, threshold
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.strength = 2.0; // 辉光强度
            bloomPass.radius = 0.5;   // 扩散半径
            bloomPass.threshold = 0.1; // 亮度阈值

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // 3. Cannon.js 物理世界设置
            world = new CANNON.World();
            world.gravity.set(0, 0, 0); // 初始无重力，由手机倾斜控制
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;

            // 材质
            const physicsMaterial = new CANNON.Material('physics');
            const physicsContactMaterial = new CANNON.ContactMaterial(physicsMaterial, physicsMaterial, {
                friction: 0.1,
                restitution: 0.7 // 弹性：0.7 表示像橡胶球
            });
            world.addContactMaterial(physicsContactMaterial);

            // 创建物理球体
            const sphereShape = new CANNON.Sphere(0.8);
            sphereBody = new CANNON.Body({
                mass: 1, // 质量为1，使其受力移动
                shape: sphereShape,
                material: physicsMaterial,
                damping: 0.1
            });
            world.addBody(sphereBody);

            // 创建隐形墙壁 (盒子) 防止球飞出去
            createBoundaries(physicsMaterial);

            // 4. 创建视觉物体
            createVisuals();

            // 5. 事件监听
            window.addEventListener('resize', onWindowResize);
            
            // 按钮事件
            const btn = document.getElementById('start-btn');
            btn.addEventListener('click', startExperience);
        }

        function createBoundaries(material) {
            // 上下左右前后 6个面
            const thickness = 1;
            const boxGeo = new CANNON.Box(new CANNON.Vec3(boundarySize, thickness, boundarySize));
            
            // 地板 (其实是屏幕背面)
            const floorBody = new CANNON.Body({ mass: 0, material: material });
            floorBody.addShape(new CANNON.Plane());
            floorBody.position.set(0, 0, -2);
            world.addBody(floorBody);

            // 顶棚 (屏幕这一侧)
            const ceilBody = new CANNON.Body({ mass: 0, material: material });
            ceilBody.addShape(new CANNON.Plane());
            ceilBody.quaternion.setFromEuler(Math.PI, 0, 0);
            ceilBody.position.set(0, 0, 2);
            world.addBody(ceilBody);

            // 四周墙壁 (简单处理：利用约束力或者反向重力，这里为了演示简单，我们只做简单的边界检查逻辑在 update 中，或者添加 4 个 Plane)
            // 为了性能和简化，我们将在 update 循环中手动限制球体位置，制造"隐形墙"效果，比添加4个物理墙更省资源且不易穿模。
        }

        function createVisuals() {
            // A. 外层笼子 (Icosahedron)
            const geo1 = new THREE.IcosahedronGeometry(1.2, 1);
            const mat1 = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff, 
                wireframe: true,
                transparent: true,
                opacity: 0.5 
            });
            coreMesh = new THREE.Mesh(geo1, mat1);
            scene.add(coreMesh);

            // B. 内部发光核心 (受物理引擎控制)
            const geo2 = new THREE.SphereGeometry(0.8, 32, 32);
            const mat2 = new THREE.MeshBasicMaterial({ color: 0xff00ff }); // 紫色
            innerCoreMesh = new THREE.Mesh(geo2, mat2);
            scene.add(innerCoreMesh);

            // C. 粒子场
            const particlesCount = 1500;
            const posArray = new Float32Array(particlesCount * 3);
            for(let i = 0; i < particlesCount * 3; i++) {
                posArray[i] = (Math.random() - 0.5) * 25;
            }
            const particlesGeo = new THREE.BufferGeometry();
            particlesGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            const particlesMat = new THREE.PointsMaterial({
                size: 0.08,
                color: 0x4444ff, // 偏蓝
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            particles = new THREE.Points(particlesGeo, particlesMat);
            scene.add(particles);
        }

        // --- 启动逻辑 (包含 Audio 初始化) ---
        async function startExperience() {
            document.getElementById('ui-layer').style.display = 'none';

            // 1. 初始化 Audio Context (必须在用户点击后)
            // 这里的 Tone 指向全局加载的对象
            await Tone.start();
            initAudio();

            // 2. 请求陀螺仪权限 (iOS)
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            window.addEventListener('deviceorientation', handleOrientation);
                        } else {
                            alert('需要传感器权限');
                        }
                    })
                    .catch(console.error);
            } else {
                window.addEventListener('deviceorientation', handleOrientation);
            }

            // PC 调试模式
            if (!/Mobi|Android/i.test(navigator.userAgent)) {
                window.addEventListener('mousemove', handleMouseSimulate);
            }

            isRunning = true;
            animate();
        }

        function initAudio() {
            // 背景低音 Drone (基于 FM 合成器)
            synth = new Tone.FMSynth({
                harmonicity: 3,
                modulationIndex: 10,
                detune: 0,
                oscillator: { type: "sine" },
                envelope: { attack: 0.1, decay: 0.01, sustain: 1, release: 0.5 },
                modulation: { type: "square" },
                modulationEnvelope: { attack: 0.5, decay: 0, sustain: 1, release: 0.5 }
            }).toDestination();
            
            // 添加混响让声音更空灵
            const reverb = new Tone.Reverb(2).toDestination();
            synth.connect(reverb);
            
            // 启动底噪
            synth.triggerAttack("C2"); 

            // 碰撞音效 (金属打击声)
            metalSynth = new Tone.MembraneSynth({
                pitchDecay: 0.05,
                octaves: 4,
                oscillator: { type: "sine" },
                envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 1.4 }
            }).toDestination();
            metalSynth.connect(reverb);
        }

        // --- 交互处理 ---
        function handleOrientation(event) {
            // 将角度 (-180 到 180) 转换为物理世界的重力向量
            // 这是一个简单的映射：倾斜手机 = 改变重力方向
            const x = event.gamma || 0; // 左右翻转
            const y = event.beta || 0;  // 前后翻转

            deviceGamma = x;
            deviceBeta = y;

            if (world) {
                // Cannon.js 的重力设置 (放大系数 0.5 让球动得快一点)
                world.gravity.set(x * 0.5, -y * 0.5, 0);
            }
        }

        function handleMouseSimulate(event) {
            // PC 鼠标模拟重力
            const x = (event.clientX / window.innerWidth) * 2 - 1;
            const y = (event.clientY / window.innerHeight) * 2 - 1;
            if (world) {
                world.gravity.set(x * 20, -y * 20, 0); // PC 上给大一点的力
            }
            deviceGamma = x * 45;
            deviceBeta = y * 45;
        }

        // --- 核心循环 ---
        function animate() {
            requestAnimationFrame(animate);

            if (!isRunning) return;

            // 1. 更新物理世界
            world.step(1 / 60);

            // 手动边界限制 (简单的箱体碰撞逻辑)
            const limitX = 3.5; // 屏幕宽度限制
            const limitY = 6.0; // 屏幕高度限制
            const vel = sphereBody.velocity;
            
            // X轴碰撞
            if (sphereBody.position.x > limitX) {
                sphereBody.position.x = limitX;
                if(vel.x > 0) { vel.x *= -0.8; triggerBounce(Math.abs(vel.x)); }
            } else if (sphereBody.position.x < -limitX) {
                sphereBody.position.x = -limitX;
                if(vel.x < 0) { vel.x *= -0.8; triggerBounce(Math.abs(vel.x)); }
            }

            // Y轴碰撞
            if (sphereBody.position.y > limitY) {
                sphereBody.position.y = limitY;
                if(vel.y > 0) { vel.y *= -0.8; triggerBounce(Math.abs(vel.y)); }
            } else if (sphereBody.position.y < -limitY) {
                sphereBody.position.y = -limitY;
                if(vel.y < 0) { vel.y *= -0.8; triggerBounce(Math.abs(vel.y)); }
            }

            // Z轴锁定 (只在平面运动)
            sphereBody.position.z = 0;
            sphereBody.velocity.z = 0;

            // 2. 同步视觉物体位置
            innerCoreMesh.position.copy(sphereBody.position);
            // 让外部线框稍微延迟跟随内部核心，产生果冻般的拖拽感
            coreMesh.position.lerp(sphereBody.position, 0.1);
            
            // 旋转效果
            coreMesh.rotation.x += 0.02;
            coreMesh.rotation.y += 0.02;
            particles.rotation.y = deviceGamma * 0.01; // 粒子背景随手机微动

            // 3. Audio 反馈逻辑 (重力乐器)
            updateAudio();

            // 4. 渲染
            composer.render();
            
            // 调试信息
            document.getElementById('debug').innerText = 
                `G-Force: X${world.gravity.x.toFixed(1)} Y${world.gravity.y.toFixed(1)}`;
        }

        function triggerBounce(velocity) {
            // 只有撞击速度够快才发声
            if (velocity > 2) {
                // 速度越快，音调越高
                const note = velocity > 10 ? "C4" : (velocity > 5 ? "G3" : "C3");
                metalSynth.triggerAttackRelease(note, "8n");
                
                // 撞击时核心闪烁白色
                innerCoreMesh.material.color.setHex(0xffffff);
                setTimeout(() => innerCoreMesh.material.color.setHex(0xff00ff), 100);
            }
        }

        function updateAudio() {
            if (!synth) return;

            // 获取球体当前速度 magnitude
            const speed = sphereBody.velocity.length();

            // 根据速度改变 Drone 的调制指数 (Modulation Index)，速度越快声音越"躁"
            // clamp(val, min, max)
            const modulation = Math.min(Math.max(speed * 2, 5), 50);
            synth.modulationIndex.rampTo(modulation, 0.1);

            // 根据屏幕垂直位置改变音调微调 (Detune)
            // 球越往上，音调越高
            const detuneVal = sphereBody.position.y * 100; // +/- 600 cents
            synth.detune.rampTo(detuneVal, 0.1);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
